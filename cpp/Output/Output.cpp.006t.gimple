void_tin ()
{
  struct allocator D.57543;
  int D.64199;

  {
    struct string cats;

    try
      {
        try
          {
            std::allocator<char>::allocator (&D.57543);
            try
              {
                std::__cxx11::basic_string<char>::basic_string<> (&cats, "", &D.57543);
              }
            finally
              {
                std::allocator<char>::~allocator (&D.57543);
              }
          }
        finally
          {
            D.57543 = {CLOBBER(eol)};
          }
        try
          {
            _1 = std::operator<< <std::char_traits<char> > (&cout, "Enter cats:");
            std::operator<< <std::char_traits<char> > (_1, "\n");
            std::operator>><char, std::char_traits<char>, std::allocator<char> > (&cin, &cats);
            _2 = std::operator<< <char, std::char_traits<char>, std::allocator<char> > (&cout, &cats);
            std::operator<< <std::char_traits<char> > (_2, "\n");
          }
        finally
          {
            std::__cxx11::basic_string<char>::~basic_string (&cats);
          }
      }
    finally
      {
        cats = {CLOBBER(eol)};
      }
  }
  D.64199 = 0;
  return D.64199;
}


__attribute__((always_inline))
void std::allocator<char>::allocator (struct allocator * const this)
{
  try
    {
      {
        std::__new_allocator<char>::__new_allocator (this);
        try
          {

          }
        catch
          {
            std::__new_allocator<char>::~__new_allocator (this);
          }
      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


__attribute__((always_inline))
void std::__new_allocator<char>::__new_allocator (struct __new_allocator * const this)
{
  try
    {
      {

      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


 std::__cxx11::basic_string<char>::basic_string<> (struct basic_string * const this, const char * __s, const struct allocator & __a)
{
  struct forward_iterator_tag D.64210;

  *this = {CLOBBER};
  {
    _1 = &this->_M_dataplus;
    _2 = std::__cxx11::basic_string<char>::_M_local_data (this);
    std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (_1, _2, __a);
    try
      {
        {
          const char * __end;

          if (__s == 0B) goto <D.64208>; else goto <D.64209>;
          <D.64208>:
          std::__throw_logic_error ("basic_string: construction from null is not valid");
          <D.64209>:
          _3 = std::char_traits<char>::length (__s);
          __end = __s + _3;
          std::__cxx11::basic_string<char>::_M_construct<const char*> (this, __s, __end, D.64210);
        }
      }
    catch
      {
        _4 = &this->_M_dataplus;
        std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (_4);
      }
  }
}


 std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (struct _Alloc_hider * const this, char * __dat, const struct allocator & __a)
{
  *this = {CLOBBER};
  {
    std::allocator<char>::allocator (this, __a);
    try
      {
        this->_M_p = __dat;
      }
    catch
      {
        std::allocator<char>::~allocator (this);
      }
  }
}


__attribute__((always_inline))
void std::allocator<char>::allocator (struct allocator * const this, const struct allocator & __a)
{
  try
    {
      {
        std::__new_allocator<char>::__new_allocator (this, __a);
        try
          {

          }
        catch
          {
            std::__new_allocator<char>::~__new_allocator (this);
          }
      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


__attribute__((always_inline))
void std::__new_allocator<char>::__new_allocator (struct __new_allocator * const this, const struct __new_allocator & D.14272)
{
  try
    {
      {

      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


 std::char_traits<char>::length (const char_type * __s)
{
  bool retval.0;
  size_t D.64216;

  retval.0 = std::__is_constant_evaluated ();
  if (retval.0 != 0) goto <D.64214>; else goto <D.64215>;
  <D.64214>:
  D.64216 = __gnu_cxx::char_traits<char>::length (__s);
  return D.64216;
  <D.64215>:
  D.64216 = __builtin_strlen (__s);
  return D.64216;
}


 std::__is_constant_evaluated ()
{
  bool D.64219;

  try
    {
      D.64219 = 0;
      return D.64219;
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
  __builtin_unreachable trap ();
}


 __gnu_cxx::char_traits<char>::length (const char_type * __p)
{
  bool retval.1;
  const char_type D.57585;
  size_t D.64222;
  size_t __i;

  __i = 0;
  goto <D.57591>;
  <D.57592>:
  __i = __i + 1;
  <D.57591>:
  try
    {
      D.57585 = 0;
      _1 = __p + __i;
      _2 = __gnu_cxx::char_traits<char>::eq (_1, &D.57585);
      retval.1 = ~_2;
    }
  finally
    {
      D.57585 = {CLOBBER(eol)};
    }
  if (retval.1 != 0) goto <D.57592>; else goto <D.57590>;
  <D.57590>:
  D.64222 = __i;
  return D.64222;
}


 __gnu_cxx::char_traits<char>::eq (const char_type & __c1, const char_type & __c2)
{
  bool D.64224;

  _1 = *__c1;
  _2 = *__c2;
  D.64224 = _1 == _2;
  return D.64224;
}


 std::__cxx11::basic_string<char>::_M_construct<const char*> (struct basic_string * const this, const char * __beg, const char * __end, struct forward_iterator_tag D.60432)
{
  size_type __dnew;
  typedef extern struct _Guard _Guard;
  struct _Guard __guard;

  try
    {
      _1 = std::distance<const char*> (__beg, __end);
      _2 = (long long unsigned int) _1;
      __dnew = _2;
      __dnew.2_3 = __dnew;
      if (__dnew.2_3 > 15) goto <D.64226>; else goto <D.64227>;
      <D.64226>:
      _4 = std::__cxx11::basic_string<char>::_M_create (this, &__dnew, 0);
      std::__cxx11::basic_string<char>::_M_data (this, _4);
      __dnew.3_5 = __dnew;
      std::__cxx11::basic_string<char>::_M_capacity (this, __dnew.3_5);
      goto <D.64228>;
      <D.64227>:
      std::__cxx11::basic_string<char>::_M_use_local_data (this);
      <D.64228>:
      std::__cxx11::basic_string<char>::_M_construct<const char*>(const char*, const char*, std::forward_iterator_tag)::_Guard::_Guard (&__guard, this);
      try
        {
          _6 = std::__cxx11::basic_string<char>::_M_data (this);
          std::__cxx11::basic_string<char>::_S_copy_chars (_6, __beg, __end);
          __guard._M_guarded = 0B;
          __dnew.4_7 = __dnew;
          std::__cxx11::basic_string<char>::_M_set_length (this, __dnew.4_7);
        }
      finally
        {
          std::__cxx11::basic_string<char>::_M_construct<const char*>(const char*, const char*, std::forward_iterator_tag)::_Guard::~_Guard (&__guard);
        }
    }
  finally
    {
      __dnew = {CLOBBER(eol)};
      __guard = {CLOBBER(eol)};
    }
}


__attribute__((always_inline, nodiscard))
difference_type std::distance<const char*> (const char * __first, const char * __last)
{
  difference_type D.64232;
  struct random_access_iterator_tag D.64233;

  std::__iterator_category<const char*> (&__first);
  __first.5_1 = __first;
  D.64232 = std::__distance<const char*> (__first.5_1, __last, D.64233);
  return D.64232;
}


__attribute__((always_inline))
struct iterator_category std::__iterator_category<const char*> (const char * const & D.63666)
{
  struct iterator_category D.64235;

  return D.64235;
}


__attribute__((always_inline))
difference_type std::__distance<const char*> (const char * __first, const char * __last, struct random_access_iterator_tag D.63675)
{
  difference_type D.64237;

  D.64237 = __last - __first;
  return D.64237;
}


__attribute__((always_inline))
char * std::__cxx11::basic_string<char>::_M_use_local_data (struct basic_string * const this)
{
  char * D.64239;

  try
    {
      D.64239 = std::__cxx11::basic_string<char>::_M_local_data (this);
      return D.64239;
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
  __builtin_unreachable trap ();
}


 std::__cxx11::basic_string<char>::_M_construct<const char*>(const char*, const char*, std::forward_iterator_tag)::_Guard::_Guard (struct _Guard * const this, struct basic_string * __s)
{
  *this = {CLOBBER};
  {
    this->_M_guarded = __s;
  }
}


 std::__cxx11::basic_string<char>::_M_construct<const char*>(const char*, const char*, std::forward_iterator_tag)::_Guard::~_Guard (struct _Guard * const this)
{
  try
    {
      {
        try
          {
            _1 = this->_M_guarded;
            if (_1 != 0B) goto <D.64241>; else goto <D.64242>;
            <D.64241>:
            _2 = this->_M_guarded;
            std::__cxx11::basic_string<char>::_M_dispose (_2);
            goto <D.64243>;
            <D.64242>:
            <D.64243>:
          }
        finally
          {
            *this = {CLOBBER};
          }
      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


 std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (struct _Alloc_hider * const this)
{
  try
    {
      try
        {

        }
      finally
        {
          std::allocator<char>::~allocator (this);
        }
    }
  finally
    {
      *this = {CLOBBER};
    }
}


__attribute__((always_inline))
void std::allocator<char>::~allocator (struct allocator * const this)
{
  try
    {
      {
        try
          {

          }
        finally
          {
            std::__new_allocator<char>::~__new_allocator (this);
          }
      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


 std::__new_allocator<char>::~__new_allocator (struct __new_allocator * const this)
{
  try
    {
      {

      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


 std::__cxx11::basic_string<char>::~basic_string (struct basic_string * const this)
{
  try
    {
      {
        try
          {
            try
              {
                std::__cxx11::basic_string<char>::_M_dispose (this);
              }
            finally
              {
                _1 = &this->_M_dataplus;
                std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (_1);
              }
          }
        finally
          {
            *this = {CLOBBER};
          }
      }
    }
  catch
    {
      <<<eh_must_not_throw (terminate)>>>
    }
}


